<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sukhman | Sanctuary</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@1,300;1,500&family=Cinzel:wght@400;700&display=swap');

        :root {
            --paper: #f4f1ea;
            --ink: #1a1a1a;
            --spidey: #8b0000;
            --envelope-bg: #e3dec9;
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background: var(--paper); overflow: hidden;
            font-family: 'Crimson Pro', serif;
        }

        #stage { 
            position: relative; width: 100vw; height: 100vh; 
            perspective: 1200px;
        }

        #stage::after {
            content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: url('https://www.transparenttextures.com/patterns/stardust.png');
            opacity: 0.12; pointer-events: none; z-index: 200;
        }

        canvas { position: absolute; top: 0; left: 0; z-index: 5; }

        #envelope-container {
            position: absolute; bottom: -300px; left: 50%;
            transform: translateX(-50%) scale(0.8);
            width: 320px; height: 200px;
            background: var(--envelope-bg);
            z-index: 100;
            transition: all 2s cubic-bezier(0.19, 1, 0.22, 1);
            opacity: 0;
            box-shadow: 0 20px 50px rgba(0,0,0,0.15);
        }

        #envelope-container.arrived {
            bottom: 10%; opacity: 1; transform: translateX(-50%) scale(1);
        }

        #flap {
            position: absolute; top: 0; left: 0; width: 0; height: 0;
            border-left: 160px solid transparent;
            border-right: 160px solid transparent;
            border-top: 110px solid #dcd7bd;
            transform-origin: top;
            transition: transform 1.2s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 110;
        }

        .opened #flap {
            transform: rotateX(180deg);
            z-index: 90; 
        }

        #letter-sheet {
            position: absolute; top: 10px; left: 10px;
            width: 300px; height: 180px;
            background: #fffdf9;
            padding: 30px; box-sizing: border-box;
            z-index: 95;
            transition: all 1.8s cubic-bezier(0.19, 1, 0.22, 1);
            box-shadow: 0 0 10px rgba(0,0,0,0.05);
            text-align: center;
            display: flex; flex-direction: column; justify-content: center;
            opacity: 0;
            overflow: hidden; /* No scroll */
        }

        .opened #letter-sheet {
            height: 520px; top: -450px; opacity: 1;
            box-shadow: 0 -15px 40px rgba(0,0,0,0.1);
        }

        p { font-size: 1rem; line-height: 1.7; color: #333; font-style: italic; margin: 0; }
        b { color: var(--spidey); font-weight: 700; }

        #hint {
            position: absolute; top: 15%; width: 100%; text-align: center;
            color: #8c8c8c; font-family: 'Cinzel', serif;
            font-size: 0.7rem; letter-spacing: 8px; z-index: 10;
        }
    </style>
</head>
<body>

<div id="stage">
    <div id="hint">Hold to reach her</div>
    <canvas id="canvas"></canvas>
    
    <div id="envelope-container">
        <div id="flap"></div>
        <div id="letter-sheet">
            <p>
                I know everything feels heavy rn. I can feel your pain my bacha, and I want you to know I'm here. <br><br>
                You can always run to me when everything feels heavy, when you can't hold your tears. My arms will always be open for you. <br><br>
                You are my safe space Sukhman. My home. My everything. And I want you to know, no matter what happens, your Spidey will always be by your side. <br><br>
                As long as I'm alive, you'll always have a shoulder to cry on. <br><br>
                <b>I'm right here, buba. Always.</b>
            </p>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const env = document.getElementById('envelope-container');

    let width, height, words = [];
    let progress = 0, isTouching = false, hasHugged = false, timer = 0;

    const gloomWords = ["ILLNESS", "ACHE", "SADNESS", "COLD", "HEAVY", "TIRED", "UNHAPPY"];

    function init() {
        width = window.innerWidth; height = window.innerHeight;
        canvas.width = width; canvas.height = height;
        words = Array.from({length: 30}, () => ({
            x: Math.random() * width, y: Math.random() * height,
            txt: gloomWords[Math.floor(Math.random()*gloomWords.length)],
            vx: (Math.random()-0.5) * 0.1, vy: Math.random() * 0.4 + 0.1,
            rot: Math.random() * Math.PI, rv: (Math.random()-0.5)*0.005,
            alpha: 0.35
        }));
    }

    function drawSilhouette(x, y, isGuy, p) {
        ctx.save();
        ctx.translate(x, y);
        if (!hasHugged) {
            let j = 2 * (1 - p);
            ctx.translate((Math.random()-0.5)*j, (Math.random()-0.5)*j);
        }
        ctx.fillStyle = isGuy ? "#8b0000" : "#2a2a2a";
        if (!isGuy) {
            ctx.beginPath(); ctx.ellipse(0, -78, 8, 10, 0, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(0, -80, 10, Math.PI, 0); ctx.fill();
            ctx.beginPath(); ctx.lineWidth = 11;
            ctx.moveTo(-9, -80); ctx.quadraticCurveTo(-16, -55, -12, -15); 
            ctx.moveTo(9, -80); ctx.quadraticCurveTo(16, -55, 12, -15);
            ctx.stroke();
            ctx.fillRect(-2, -68, 4, 6);
            ctx.beginPath(); ctx.moveTo(-6, -62); ctx.lineTo(6, -62);
            ctx.lineTo(18, 5); ctx.lineTo(-18, 5); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.roundRect(-8, 5, 5, 30, 2); ctx.roundRect(3, 5, 5, 30, 2); ctx.fill();
        } else {
            ctx.beginPath(); ctx.ellipse(0, -85, 10, 12, 0, 0, Math.PI * 2); ctx.fill();
            ctx.fillRect(-3, -75, 6, 8);
            ctx.beginPath(); ctx.roundRect(-14, -68, 28, 58, 6); ctx.fill();
            ctx.beginPath(); ctx.roundRect(-12, -10, 9, 45, 4); ctx.roundRect(3, -10, 9, 45, 4); ctx.fill();
            ctx.beginPath(); ctx.lineWidth = 8; ctx.lineCap = 'round';
            ctx.moveTo(8, -58); ctx.lineTo(12 + (p * 35), -53 + (p * 8)); ctx.stroke();
        }
        ctx.restore();
    }

    function loop() {
        ctx.fillStyle = hasHugged ? "rgba(244, 241, 234, 0.04)" : "rgba(244, 241, 234, 0.2)";
        ctx.fillRect(0, 0, width, height);

        let inc = (progress > 0.88) ? 0.0006 : 0.006;
        if (isTouching && progress < 1) progress += inc;
        else if (!isTouching && !hasHugged) progress = Math.max(0, progress - 0.01);

        if (hasHugged) {
            timer++;
            if (timer === 60) env.classList.add('arrived');
            if (timer === 180) env.classList.add('opened');
            let pulse = Math.sin(Date.now() * 0.0015) * 15;
            let g = ctx.createRadialGradient(width/2, height/2 - 20, 0, width/2, height/2 - 20, 200 + pulse);
            g.addColorStop(0, 'rgba(139, 0, 0, 0.04)');
            g.addColorStop(1, 'transparent');
            ctx.fillStyle = g;
            ctx.beginPath(); ctx.arc(width/2, height/2 - 20, 200 + pulse, 0, Math.PI * 2); ctx.fill();
        }

        ctx.font = "italic 600 13px 'Crimson Pro'"; ctx.textAlign = "center";
        words.forEach(w => {
            w.x += w.vx; w.y += w.vy; w.rot += w.rv;
            if (!hasHugged) {
                if (w.y > height) w.y = -20;
                ctx.fillStyle = `rgba(30, 30, 30, ${w.alpha})`;
            } else {
                w.alpha *= 0.98;
                ctx.vx *= 0.98; w.vy *= 0.98;
                ctx.filter = `blur(${timer/40}px)`;
                ctx.fillStyle = `rgba(30, 30, 30, ${w.alpha})`;
            }
            ctx.save(); ctx.translate(w.x, w.y); ctx.rotate(w.rot);
            ctx.fillText(w.txt, 0, 0); ctx.restore();
            ctx.filter = 'none';
        });

        const cy = height/2 + 20;
        let gx = (width * 0.15) + (progress * (width * 0.35 - 12)); 
        let sx = (width * 0.85) - (progress * (width * 0.35 - 12));

        if (!hasHugged) {
            drawSilhouette(sx, cy, false, progress);
            drawSilhouette(gx, cy, true, progress);
        } else {
            drawSilhouette(width/2 - 12, cy, true, 1);
            drawSilhouette(width/2 + 12, cy, false, 1);
        }

        if (progress >= 0.99 && !hasHugged) {
            hasHugged = true;
            document.getElementById('hint').style.opacity = 0;
            words.forEach(w => {
                let dx = w.x - width/2, dy = w.y - (height/2);
                let d = Math.max(1, Math.sqrt(dx*dx + dy*dy));
                w.vx = (dx/d) * 8; w.vy = (dy/d) * 8;
            });
        }
        requestAnimationFrame(loop);
    }

    const start = (e) => { e.preventDefault(); isTouching = true; };
    const end = () => isTouching = false;
    window.addEventListener('mousedown', start); window.addEventListener('mouseup', end);
    window.addEventListener('touchstart', start); window.addEventListener('touchend', end);
    window.addEventListener('resize', init);
    init(); loop();
</script>
</body>
</html>